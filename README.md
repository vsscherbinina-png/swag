Цель работы
Освоить фундаментальные алгоритмы сортировки и поиска, исследовать их принципы функционирования и провести оценку производительности на основе временной сложности. Реализовать алгоритмы на языках программирования Python и C++, провести сравнительный анализ подходов и особенностей реализации.

Теоретические основы
Алгоритмы сортировки предназначены для организации данных в определенном порядке (возрастания или убывания). Алгоритмы поиска решают задачу нахождения заданного элемента в структурах данных. Каждый алгоритм обладает уникальными характеристиками, областью применения, преимуществами и ограничениями.

Алгоритмы сортировки
Сортировка выбором (Selection Sort) — C++
Принцип работы: Алгоритм последовательно находит минимальный элемент в неотсортированной части массива и перемещает его на текущую позицию. Процесс повторяется до полного упорядочивания массива.

Сложность: O(n²)
Особенности: Интуитивно понятная реализация, но низкая производительность на больших объемах данных


Сортировка пузырьком (Bubble Sort) — Python
Принцип работы: Алгоритм многократно сравнивает соседние элементы и меняет их местами при нарушении порядка. На каждой итерации наибольший элемент "всплывает" к концу массива.

Сложность: O(n²)
Особенности: Простейшая реализация, эффективен для почти отсортированных массивов


Сортировка вставками (Insertion Sort) — Python
Принцип работы: Массив разделяется на отсортированную и неотсортированную части. Каждый новый элемент вставляется в правильную позицию в отсортированной секции.

Сложность: O(n²)
Особенности: Эффективен для малых массивов и частично упорядоченных данных


Сортировка слиянием (Merge Sort) — Python
Принцип работы: Алгоритм использует стратегию "разделяй и властвуй" - рекурсивно делит массив пополам, сортирует каждую половину и объединяет их в упорядоченную последовательность.

Сложность: O(n log n)
Особенности: Стабильная производительность, требует дополнительной памяти


Сортировка Шелла (Shell Sort) — C++
Принцип работы: Улучшенная версия сортировки вставками с использованием убывающих промежутков между сравниваемыми элементами.

Сложность: O(n^1.5)
Особенности: Повышенная эффективность по сравнению с простыми квадратичными алгоритмами


Быстрая сортировка (Quick Sort) — Python
Принцип работы: Алгоритм выбирает опорный элемент, разделяет массив на элементы меньше и больше опорного, затем рекурсивно сортирует полученные части.

Сложность: O(n log n) в среднем, O(n²) в худшем случае
Особенности: Один из самых эффективных алгоритмов на практике


Пирамидальная сортировка (Heap Sort) — C++
Принцип работы: Алгоритм использует структуру данных "двоичная куча" для построения максимальной кучи и последовательного извлечения наибольших элементов.

Сложность: O(n log n)
Особенности: Не требует дополнительной памяти, стабильная производительность


Алгоритмы поиска
Линейный поиск — C++
Принцип работы: Последовательная проверка каждого элемента массива до нахождения искомого значения или завершения массива.

Сложность: O(n)
Особенности: Универсальный метод, применим к неотсортированным данным


Бинарный поиск — Python
Принцип работы: Эффективный алгоритм для отсортированных массивов, на каждом шаге уменьшающий область поиска вдвое.

Сложность: O(log n)
Особенности: Высокая эффективность для упорядоченных структур данных


Интерполяционный поиск — Python
Принцип работы: Усовершенствованный бинарный поиск, определяющий позицию проверки на основе значения искомого элемента.

Сложность: O(log log n) при равномерном распределении
Особенности: Максимальная эффективность при равномерном распределении данных


Поиск Фибоначчи — C++
Принцип работы: Алгоритм использует числа Фибоначчи для определения оптимальных точек разделения массива.

Сложность: O(log n)
Особенности: Эффективная альтернатива бинарному поиску
